package io.nebulas.core;


import io.nebulas.crypto.hash.Hash;
import io.nebulas.util.Base58;
import io.nebulas.util.ByteUtils;

/**
 * This Address class implements
 * <a href="https://github.com/nebulasio/wiki/blob/master/address.md">Nebulas Address Design </a>.
 * There are two type of address: account address and contract address.
 * <p>
 * <p>An address has two data forms: bytes address and string address. The bytes address is an array of 26 bytes,
 * and the string address is Base58 encode of bytes address.
 * <p>Examples of bytes address and string address:
 * <ul>
 *     <li>bytes address: {@code [25,87,28,9,140,12,125,159,7,158,22,96,209,211,96,26,132,247,93,227,1,195,40,228,147,89]}</li>
 *     <li>string address: {@code "n1H56f7wTLu389iX6ufP2VkWBynindaxXvx"}</li>
 * </ul>
 *<br>
 * <br>
 * <p>The Address class mainly handle address related tasks, such as:
 * <ul>
 *     <li>generate new account address from account public key</li>
 *     <li>conversion between string address and bytes address</li>
 *     <li>get address object by parsing a given string address or bytes address</li>
 * </ul>
 * <br>
 * An original address should be generated by AccountManager, as shown in the example code blow.
 * <pre>
 * {
 *     byte[] passphrase = "passphrase".getBytes();    //prepare your passphrase
 *     AccountManager manager = new AccountManager();
 *     Address address = manager.newAccount(passphrase);
 * }
 * </pre>
 *
 */
public class Address {

    private static final byte PaddingByte = 0x19;
    private static final char NebulasFaith = 'n';

    // AddressPaddingLength the length of headpadding in byte
    private static final int AddressPaddingLength = 1;

    // AddressTypeLength the length of address type in byte
    private static final int AddressTypeLength = 1;

    // AddressTypeIndex the index of address type bytes
    private static final int AddressTypeIndex = 1;

    // AddressDataLength the length of data of address in byte.
    private static final int AddressDataLength = 20;

    // AddressChecksumLength the checksum of address in byte.
    private static final int AddressChecksumLength = 4;

    // AddressLength the length of address in byte.
    private static final int AddressLength = AddressPaddingLength + AddressTypeLength + AddressDataLength + AddressChecksumLength;

    /**
     * The length of public key, which is 65.
     */
    // PublicKeyDataLength length of public key
    public static final int PublicKeyDataLength = 65;

    /**
     * The length of address in the form of base58, which is 35.
     */
    // AddressBase58Length length of base58(Address.address)
    public static final int AddressBase58Length = 35;

    /**
     * The enum of Address type.
     */
    // address type
    public enum AddressType {
        /**
         * Normal address format, used for transaction address.
         */
        // normal address format, used for transaction address
        ACCOUNT((byte) 0x57),

        /**
         * Contract address type, used for contract address.
         */
        // contract address type, used for contract address
        CONTRACT((byte) 0x58);

        private byte type;

        private AddressType(byte type) {
            this.type = type;
        }

        /**
         * Get the Address type.
         *
         * @return the byte
         */
        public byte Type() {
            return this.type;
        }
    }

    private byte[] address;

    private Address(byte[] address) {
        this.address = address;
    }

    /**
     * Get the bytes address, which is an array of 26 bytes.
     * Such as <tt>[25,87,28,9,140,12,125,159,7,158,22,96,209,211,96,26,132,247,93,227,1,195,40,228,147,89]</tt>
     *
     * @return the account address, which is a byte array.
     */
    public byte[] bytes() {
        return address;
    }

    /**
     * Get the string address, which is calculated by encoding the address bytes array with Base58.
     * Such as <tt>"n1H56f7wTLu389iX6ufP2VkWBynindaxXvx"</tt>.
     * @return the address string.
     */
    public String string() {
        return Base58.encode(this.address);
    }

    /**
     * Get the address type of this address.
     *
     * @return the address type
     * @throws Exception if the type is neither ACCOUNT or CONTRACT,
     */
    public AddressType type() throws Exception {
        byte type = address[AddressTypeIndex];
        if (AddressType.ACCOUNT.Type() == type) {
            return AddressType.ACCOUNT;
        } else if (AddressType.CONTRACT.Type() == type) {
            return AddressType.CONTRACT;
        } else {
            throw new Exception("unsupport address type");
        }
    }

    /**
     * Generates a new address from given information:
     * <p> -- generate account address from account public key
     * <p> -- generate contract address from string address and nonce of the account deploying this contract
     * The algorithm that used for generating addresses is described in
     * <a href="https://github.com/nebulasio/wiki/blob/master/address.md">wiki:address.md</a>
     *
     * @param type the address type
     * @param args the args for generating this address
     * @return the generated address
     * @throws Exception
     */
    private static Address newAddress(AddressType type, byte[]... args) throws Exception {
        if (args.length == 0) {
            throw new Exception("invalid argument(s)");
        }
        if (AddressType.ACCOUNT != type && AddressType.CONTRACT != type) {
            throw new Exception("invalid address type");
        }

        byte[] addrBytes = new byte[AddressLength];
        addrBytes[0] = PaddingByte;
        addrBytes[AddressTypeIndex] = type.Type();
        byte[] sha = Hash.Sha3256(args);
        byte[] content = Hash.Ripemd160(sha);
        System.arraycopy(content, 0, addrBytes, AddressTypeIndex + 1, AddressDataLength);

        byte[] checkData = ByteUtils.SubBytes(addrBytes, 0, AddressLength - AddressChecksumLength);
        byte[] checkSum = checkSum(checkData);
        System.arraycopy(checkSum, 0, addrBytes, AddressLength - AddressChecksumLength, AddressChecksumLength);

        Address address = new Address(addrBytes);
        return address;
    }

    /**
     * Get the checksum for generating new account.
     * the checksum is the first 4 bytes of SHA3256(data)
     *
     * @param data the data used to get checksum
     * @return the returned checksum, an array of 4 bytes
     */
    private static byte[] checkSum(byte[] data) {
        byte[] checkData = Hash.Sha3256(data);
        return ByteUtils.SubBytes(checkData, 0, AddressChecksumLength);
    }

    /**
     * Make a new account address from a given pub key.
     *
     * @param pub the given pub key, which is a byte array.
     * @return an Address object
     * @throws Exception the exception
     */
    public static Address NewAddressFromPubKey(byte[] pub) throws Exception {
        if (pub.length != PublicKeyDataLength) {
            throw new Exception("invalid pubKey for address");
        }
        return newAddress(AddressType.ACCOUNT, pub);
    }

    /**
     * Make a new contract address address with given address bytes and nonce.
     *
     * @param from  the byte array of contract address
     * @param nonce the nonce
     * @return an Address object
     * @throws Exception if the byte array is empty or the nonce is empty
     */
    public static Address NewContractAddress(byte[] from, byte[] nonce) throws Exception {
        if (from.length == 0 || nonce.length == 0) {
            throw new Exception("invalid from or nonce");
        }
        return newAddress(AddressType.CONTRACT, from, nonce);
    }

    /**
     * Get the Account object from a string address.
     *
     * @param addr the string address of an account.
     * @return the returned address object.
     * @throws Exception if the length of string address is not 35, or the first letter of string address is not "n"
     */
    public static Address ParseFromString(String addr) throws Exception {
        if (addr.length() != AddressBase58Length || addr.charAt(0) != NebulasFaith) {
            throw new Exception("invalid address string format");
        }
        byte[] addrBytes = Base58.decode(addr);
        return ParseFromBytes(addrBytes);
    }

    /**
     * Get the Account object from a byte address.
     *
     * @param bytes the byte address
     * @return the returned address object.
     * @throws Exception if the length of byte address is not 26, or the first element of byte address is not "n"
     */
    public static Address ParseFromBytes(byte[] bytes) throws Exception {
        if (bytes.length != AddressLength || bytes[0] != PaddingByte) {
            throw new Exception("invalid address bytes");
        }

        byte[] checkSum = ByteUtils.SubBytes(bytes, AddressLength - AddressChecksumLength, AddressChecksumLength);
        byte[] checkData = ByteUtils.SubBytes(bytes, 0, AddressLength - AddressChecksumLength);
        if (!ByteUtils.Equal(checkSum(checkData), checkSum)) {
            throw new Exception("invalid address check sum");
        }

        return new Address(bytes);
    }

}
